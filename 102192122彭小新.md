https://github.com/1440465053/Software-engineering/tree/main/102192122

# 一、PSP表格

| PSP2.1                                  | Personal Software Process Stages        | 预估耗时（分钟） | 实际耗时（分钟） |
| --------------------------------------- | --------------------------------------- | :--------------: | :--------------: |
| Planning                                | 计划                                    |                  |                  |
| · Estimate                              | · 估计这个任务需要多少时间              |        10        |        10        |
| Development                             | 开发                                    |                  |                  |
| · Analysis                              | · 需求分析 (包括学习新技术)             |       2000       |       1200       |
| · Design Spec                           | · 生成设计文档                          |        0         |        0         |
| · Design Review                         | · 设计复审                              |        0         |        0         |
| · Coding Standard                       | · 代码规范 (为目前的开发制定合适的规范) |        0         |        0         |
| · Design                                | · 具体设计                              |       160        |       180        |
| · Coding                                | · 具体编码                              |       600        |       1800       |
| · Code Review                           | · 代码复审                              |        60        |        30        |
| · Test                                  | · 测试（自我测试，修改代码，提交修改）  |       360        |        60        |
| Reporting                               | 报告                                    |                  |                  |
| · Test Repor                            | · 测试报告                              |        30        |        10        |
| · Size Measurement                      | · 计算工作量                            |        30        |        10        |
| · Postmortem & Process Improvement Plan | · 事后总结, 并提出过程改进计划          |        30        |        60        |
|                                         | · 合计                                  |       3280       |       3350       |

# 二、任务要求的实现

- **(3.1)项目设计与技术栈。从阅读完题目到完成作业，这一次的任务被你拆分成了几个环节？你分别通过什么渠道、使用什么方式方法完成了各个环节？列出你完成本次任务所使用的技术栈。（5'）**
  1. 学习Python，通过[Python知识学习网站](https://learnku.com/docs/byte-of-python/2018/about_python/3338)，初步了解Python
  2. 学习爬虫相关知识，通过B站[Python爬虫入门课](https://www.bilibili.com/video/BV1464y1c7Eq?is_story_h5=false&p=1&share_from=ugc&share_medium=android&share_plat=android&share_session_id=ddaa36b8-e3d9-443e-bce5-cdd8a3f095ec&share_source=QQ&share_tag=s_i&timestamp=1662341822&unique_k=sJCOOeq&vd_source=6941a56280c6ffab3a8b4a7730c92a5e)初步了解爬虫相关知识
  3. 学习反爬相关知识，[pyppeteer工具包](https://blog.51cto.com/u_14137942/2736232)
  4. 学习数据输出表格，通过CSDN学习`xlrd`、`xlwd`工具包，将爬取数据导入EXCEL
  5. 学习数据可视化，通过`pyecharts`[官方文档](https://pyecharts.org/#/zh-cn/)学习数据输出为柱状图

- **(3.2)爬虫与数据处理。说明业务逻辑，简述代码的设计过程（例如可介绍有几个类，几个函数，他们之间的关系），并对关键的函数或算法进行说明。（20'）**
  1. 通过pyppeteer工具包，绕过卫健委的反爬机制，用于发起网络请求，获取网页源码。

     ```python
     async def pyppteer_fetchUrl(url):
         browser = await launch({'headless': False, 'dumpio': True, 'autoClose': True})
         page = await browser.newPage()
     
         await page.goto(url)  # 加不加timeout都报超时错误
         await asyncio.wait([asyncio.create_task(page.waitForNavigation())])
         # await asyncio.wait([page.waitForNavigation()])，过时报错，虽然不影响
         str = await page.content()
         await browser.close()
         return str
     
     
     def fetchUrl(url):
         return asyncio.get_event_loop().run_until_complete(pyppteer_fetchUrl(url))
     ```
  
  2. 通过 getContent 函数，获取某一篇文章的正文内容。
  
     ```python
     def getContent(html):
         bsobj = BeautifulSoup(html, 'html.parser')
         cnt = bsobj.find('div', attrs={"id": "xw_box"}).find_all("p")
         s = ""
         if cnt:
             for item in cnt:
                 s += item.text
             return s
     
         return "爬取失败！"
     ```
  
  3. 对获取的内容进行匹配，先将内容进行第一次匹配保留本土新增确诊和本土无症状两句话就好了
     ```python
     def match(content):
         ......
         # 从卫健委爬取的文章做一次裁剪，保留本土病例新增确诊那句就好了
         confirm_text = re.search('本土病例(\d*)例（.*?）', content, re.DOTALL)
         #从卫健委爬取的文章做一次裁剪，保留本土病例新增无症状那句就好了
         asymptomatically_text = re.search('新增无症状感染者\d*例.*?本土(\d*)例（.*?）', content, re.DOTALL)
     ```
  
  4. 匹配新增确诊函数,从是上面匹配出的结果进行再次匹配，第一个参数为中文省份名，第二个参数为拼音省份名，匹配正则表达式，将匹配到的数字追加到到相应省份字典里，如果返回为空，则添加数据0。
  
     ```python
     # 匹配各省新增确诊函数
         def match_confirm_add_province(province, province_pinyin):
             if re.search('{}(.*?)例'.format(province), confirm_text.group(0), re.DOTALL):
                 confirm_add_num = (re.search('{}(.*?)例'.format(province), confirm_text.group(0), re.DOTALL)).group(1)
                 confirm_add[province_pinyin].append(confirm_add_num)
             else:
                 confirm_add[province_pinyin].append('0')
                 
     	for i in province_all: # province_all为字典，键为中文省份，值为拼音省份
             match_only_confirm_province(i, province_all[i])
     ```
  
  5. 将数据保存到EXCEL表格
  
     ```python
     # 设置第一行为日期、各个省份
         for i in range(len(col)):
             sheet_confirm.write(0, i, col[i])
             sheet_asymptomatically.write(0, i, col[i])
         m = 0
         # 将每日新增确诊数据写入sheet_confirm表
         for j in match_data.confirm_add.keys():
             list_1 = list(match_data.confirm_add[j])
             for k in range(len(list_1)):
                 sheet_confirm.write(k + 1, m, list_1[k])
             m += 1
         # 将每日新增无症状输入写入sheet_asymptomatically
         m = 0
         for n in match_data.asymptomatically_add.keys():
             list_2 = list(match_data.asymptomatically_add[n])
             for a in range(len(list_2)):
                 sheet_asymptomatically.write(a + 1, m, list_2[a])
             m += 1
     ```
  
  6. 获取EXCEL表格数据就绘制出各省份每日新增柱状图
  
     ```python
      # X轴为省份，y轴每天新增感染和每天新增无症状感染数量
         xdata = []
         ydata_confirm = []
         ydata_asymptomatically = []
     
         row = 0
         # 匹配传递日期参数，找到相应日期的行数
         for i in range(1, confirm_table.nrows):
             if confirm_table.row_values(i)[0] == year_mon_day:
                 row = i
                 break
         # 获取相应行数各个省份的数据
         for i in range(2, confirm_table.ncols):
             xdata.append(confirm_table.row_values(0)[i])
             ydata_confirm.append(confirm_table.row_values(row)[i])
             ydata_asymptomatically.append(asymptomatically_table.row_values(row)[i])
     ```
  
- **(3.3)数据统计接口部分的性能改进。记录在数据统计接口的性能上所花费的时间，描述你改进的思路，并展示一张性能分析图（例如可通过VS 2019/JProfiler的性能分析工具自动生成），并展示你程序中消耗最大的函数。（6'）**

  用的最多的是fetchUrl函数，用pyppeteer工具包，进行网络请求获取网页源码。

  ![image-20220915193102949](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5045/image-20220915193102949.png)

- **(3.4)每日热点的实现思路。简要介绍实现该功能的算法原理，可给出必要的步骤流程图、数学公式推导和核心代码实现，并简要谈谈所采用算法的优缺点与可能的改进方案。（6'）**

  没有实现

- **(3.5)数据可视化界面的展示。在博客中介绍数据可视化界面的组件和设计的思路。（15'）**

  使用`pyecharts`模块实现，利用`xlrd、xlwd`将EXCEL数据读取使用`pyecharts`绘制出柱状图输出为HTML格式。

  程序可修改参数，进而显示某日各地新增确诊和无症状感染者

  ![image-20220915193657796](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5045/image-20220915193657796.png)

  ![image-20220915193914673](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5045/image-20220915193914673.png)

  ![image-20220915193950565](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/5045/image-20220915193950565.png)

# 三、心得体会

- **(4.1)在这儿写下你完成本次作业的心得体会，当然，如果你还有想表达的东西但在上面两个板块没有体现，也可以写在这儿~（10'）**

  ​		第一次真正意义上的自学自己写程序（除了爬取卫健委部分的代码），不知道咋说，从学习Python还有爬虫，工具包的使用花费了大量时间，但是收获也颇多，第一次进行频繁大量的Debug，找出一些细节上的问题，比如匹配时的正则表达式`.*?`写成中文`.*？`返回结果总是空。最早爬取网页每天的疫情文本数据后，从整个文本后直接匹配关键字，发现正则表达式不是很好兼容，之后直接先抓取本土每日新增关键句，新增无症状关键句再进行匹配，正则表达式简单多了，还有很多感悟，就不写了。

  ​		自己看自己的代码都发现很多不足，封装性体现较差，很多函数可以合并成一个简单的函数但是因为需要改写程序较多出，工作量有点大，没敢动。数据抓取错误，数据不准确也会出现，但是因为身体原因和时间原因不打算改了。躺平了！

